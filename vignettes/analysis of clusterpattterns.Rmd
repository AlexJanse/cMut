---
title: "Find and annotate mutational clusters with cMut"
author: "Alex Janse"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
```{r global_options, include = FALSE}
old <- options(tibble.width = Inf)
on.exit(options(old), add = TRUE)
```
The cMut package provide functions to find and annotate clustered mutations.
In the following examples, the functions will be explained and used.


## createRandomMutations
The `cMut::createRandomMutation()` function will create random single nucleotide variant (SNV) mutations in the human reference genome (GRCh37/hg19) and store them in a tibble (table object from the tidyverse package). The surrounding nucleotides are also from the reference genome.
```{r include=TRUE}
randomData <- cMut::createRandomMutations(nMut = 1000)
randomData
```

If a tibble is inconvenience, use the `tibble = FALSE` argument to get a data frame.
It is also possible to change the number of surrounding nucleotides with the `sizeSur` argument:
```{r include = T}
cMut::createRandomMutations(nMut = 10, 
                            tibble = FALSE,
                            sizeSur = 4)
```


## identifyAndAnnotateClusters
The `cMut::identifyAndAnnotateClusters()` applies the `cMut::identifyClusters()` and if wanted the `cMut::linkPatterns()` to every row of the sent table. Beside those functions, it will also add the distance towards the nearest mutations and columns with booleans whether or not the function it referring to gave results. Make sure that the default arguments for column names correspond with the column headers of the sent table and change if needed.

```{r include = TRUE}
results <- cMut::identifyAndAnnotateClusters(x = randomData, 
                                             maxDistance = 20000,
                                             tibble = FALSE)
results[results$is.clustered == T,]
```

If the `cMut::linkPatterns()` is needed, use the `linkPatterns = TRUE` argument. See the `cMut::linkPatterns()` paragraph for more information
```{r include = TRUE}
results <- cMut::identifyAndAnnotateClusters(x = randomData, 
                                             maxDistance = 20000,
                                             tibble = FALSE,
                                             linkPatterns = TRUE)
results[results$is.linked == T,]
```

## identifyClusters.R
The `cMut::identifyCluster()` function finds clusters in a table and returns a vector with cluster IDs.

```{r include = TRUE}
resultVector <- cMut::identifyClusters(x = randomData,
                 maxDistance = 20000,
                 chromHeader = "chrom",
                 positionHeader = "start",
                 sampleIdHeader = "sampleIDs")
head(resultVector)
```

## linkPatterns
The `cMut::linkPatterns()` function can check if the provided mutation can be matched with known mutation patterns in a table and returns the ID of the match.
If no table is sent the default table is used:

```{r echo = FALSE}
getData <- function(){
  tempWd <- setwd(paste0(.libPaths(),"/cMut")) 
  on.exit(setwd(tempWd), add = T)
  return(tibble::as.tibble(readRDS("data/mutationPatterns.rds")))
}
print("DEFAULT TABLE:")
getData()
```

A proper way of using this function with the default table:
```{r include = TRUE}
cMut::linkPatterns("C","T","TA.T")
```

As visible in the default table, it is possible to use alternative nucleotide symbols. However it is not possible to use these symbols in the look up mutation:
```{r include = TRUE, error = TRUE}
cMut::linkPatterns("C","D","A.A")
```


## groupClusters
The `cMut::groupClusters()` function is best used as an optional followup function for `cMut::identifyAndAnnotateClusters()`. This function will group the data based on the cluster IDs. 
```{r include = TRUE}
groups <- cMut::groupClusters(table = results,
                    tibble = FALSE)
# The cMuts column contains lists of mutations that belong to the cluster.
# It's excluded because it messed up the format.
groups[,-which(names(groups) == "cMuts")] 
```

If the `linkPatterns = TRUE` argument is used during the `cMut::identifyAndAnnotateClusters()` function or the custom table have a similar column then it is possible to use the `patternIntersect = TRUE` argument in the `cMut::groupClusters()` to add a column with the intersection of the patterns per cluster.
```{r include = TRUE}
groups <- cMut::groupClusters(table = results,
                    patternIntersect = TRUE)
# The cMuts column contains lists of mutations that belong to the cluster.
# It's excluded because it messed up the format.
groups[,-which(names(groups) == "cMuts")] 
```

### Bugs, questions, suggestions?
Feel free to the contact the creator! (^__^)
See info in the DESCRIPTION file.
