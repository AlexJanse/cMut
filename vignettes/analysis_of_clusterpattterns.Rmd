---
title: "Find and annotate mutational clusters with cMut"
author: "Alex Janse"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Vignette Title}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```
```{r include = FALSE}
library(cMut)
```
The cMut package provide functions to find and annotate clustered mutations.
In the following examples, the functions will be explained and used.


## createRandomMutations
The `createRandomMutation()` function will create random single nucleotide variant (SNV) mutations in the human reference genome GRCh37/hg19 (or GRch38/hg38 if `refGenomeHg19 = FALSE`) and store them in a tibble (table object from the tidyverse package). The surrounding nucleotides are also from the reference genome.
```{r include=TRUE}
randomData <- createRandomMutations(nMut = 10)
randomData
```

For more information about the table use:
```{r include = TRUE}
cat(comment(randomData))
```

If a tibble is inconvenience, use the `asTibble = FALSE` argument to get a data table.
It is also possible to change the number of surrounding nucleotides with the `sizeSur` parameter, the chromosomes that are needed to be used and change the reference genome from Hg19 to Hg38 with the `refGenomeHg19 = F` parameter:
```{r include = T}
createRandomMutations(nMut = 10, 
                      asTibble = FALSE,
                      sizeSur = 4,
                      refGenomeHg19 = F,
                      useChrom = c("chr1","chr2"))
```

## Default mutation patterns
The following functions use a search table to see if it is possible to match the mutation with certain mutation patterns. If no search table is sent through the parameters, the default is used:
```{r echo = FALSE}
print(mutationPatterns)
```
As seen in the table, there are two kinds of patterns:
* Patterns with 1 reference, 1 alternative, with surrounding nucleotides and a maximum distance with a number or NA. These are used in the `identifyAndAnnotateClusters()` and `linkPatterns()` functions.
* Patterns with more than 1 or no reference, more than 1 alternative, no surrounding nucleotides and always a maximum distance. These are used in the `groupClusters()` function. These are separated evaluated from the other patterns because these patterns depend on the order and distance of the mutations within a cluster.


## identifyAndAnnotateClusters
The `identifyAndAnnotateClusters()` searchs for clusters by looking per sample per chromosome if there are mutations within the range of the maximum distance and (if wanted) applies `linkPatterns()` to every clsutered mutation row of the sent table (to link every row, use the `linkClustersOnly = FALSE` parameter). Beside those functions, it will also add the distance towards the nearest mutations and columns with Booleans whether or not the function it referring to gave results. Make sure that the default arguments for column names correspond with the column headers of the sent table or change it if needed.

```{r include = TRUE}
results <- identifyAndAnnotateClusters(dataTable = testDataSet, 
                                       maxDistance = 20000,
                                       asTibble = FALSE)
head(results[results$is.clustered == T,])
```

If the `linkPatterns()` is needed, use the `linkPatterns = TRUE` argument. See the `linkPatterns()` paragraph for more information about the function.
```{r include = TRUE}
results <- identifyAndAnnotateClusters(dataTable = testDataSet, 
                                       maxDistance = 20000,
                                       asTibble = FALSE,
                                       linkPatterns = TRUE)
head(results[results$is.linked == T,])
```

When using a dataset with column names or others that do not match with the default use make sure to change the corresponding parameters.
```{r include = FALSE}
x <- testDataSet
names(x) <- c("chr","pos","endPos","reference","variant","id","sur")
x$sur <- gsub("\\.","-",x$sur)
```
```{r include = TRUE}
# testDataSet with different column names
x
results <- identifyAndAnnotateClusters(dataTable = x, 
                                       maxDistance = 20000,
                                       altHeader = "variant",
                                       refHeader = "reference",
                                       mutationSymbol = "-",
                                       positionHeader = "pos",
                                       sampleIdHeader = "id",
                                       contextHeader = "sur",
                                       chromHeader = "chr",
                                       linkPatterns = TRUE)
head(results[results$is.linked == T,])
```

for more information about the added clusters use:
```{r include = TRUE}
cat(comment(results))
```

## identifyClusters.R
The `identifyCluster()` function finds clusters in a table and returns a vector with cluster IDs.
A cluster is defined as mutations that lie within the maximum distance of each other within a chromosome.

```{r include = TRUE}
resultVector <- identifyClusters(x = testDataSet,
                 maxDistance = 20000,
                 chromHeader = "chrom",
                 positionHeader = "start",
                 sampleIdHeader = "sampleIDs")
tail(resultVector)
```

## linkPatterns
The `linkPatterns()` function will check if the provided mutation can be matched with known mutation patterns in a table and returns the ID of the match.
If no table is sent the default table is used with only the patterns with single nucleotide reference\\variant. See `Default mutation patterns` above for more information.

A proper way of using this function with the default table:
```{r include = TRUE}
linkPatterns("A","T","TA.T")
```

If distance is important, use the `distance` parameter to tell the distance to the nearest mutation within a cluster. Make sure that the search pattern table has a column with the maximum distance.
```{r include = T}
linkPatterns("A","T","TA.T",550)
linkPatterns("A","T","TA.T",50)
```

As visible in the default table, it is possible to use alternative nucleotide symbols. However it is not possible to use these symbols in the look up mutation:
```{r include = TRUE, error = TRUE}
linkPatterns("C","D","A.A")
```

It is possible that the reference nucleotide is an N. In this case no match is possible because the N represent for every nucleotide. In this case the function shall simply give an empty list back:
```{r include = TRUE}
linkPatterns("N","C","TT.")
```


## groupClusters
The `groupClusters()` function is best used as a followup function for `identifyAndAnnotateClusters()`. This function will group the data based on the cluster IDs. 
```{r include = TRUE}
groups <- groupClusters(table = results,
                    tibble = FALSE)

# The cMuts column contains lists of mutations that belong to the cluster.
# It's excluded in the preview because it messed up the format.
head(groups[,-which(names(groups) == "cMuts")])
```

If the `linkPatterns = TRUE` argument is used during the `identifyAndAnnotateClusters()` function or the custom table have a similar column then it is possible to use the `patternIntersect = TRUE` argument in the `groupClusters()` to add a column with the intersection of the patterns per cluster.
```{r include = TRUE}
groups <- groupClusters(table = results,
                    patternIntersect = TRUE)

# The cMuts column contains lists of mutations that belong to the cluster.
# It's excluded because it messed up the format.
head(groups[,-which(names(groups) == "cMuts")])

# Because multiple patterns might matched the results, the patterns are put into a list.
groups[groups$has.intersect == T,]$foundPatterns
```

It is also possible to search for cluster mutation patterns. See the `Default mutation patterns` chapter above for more information about these patterns.
```{r include = TRUE}
groups <- groupClusters(table = results,
                        searchClusterPatterns = TRUE)
head(groups)
groups[groups$has.clusterPatterns == T,]$foundPatterns
```

When combined with the `patternIntersect`:
```{r include = TRUE}
groups <- groupClusters(table = results,
                        patternIntersect = TRUE,
                        searchClusterPatterns = TRUE)
head(groups)
groups[groups$has.clusterPatterns == T | groups$has.intersect == T,]$foundPatterns
```

for more information about the columns of the group function, use:
```{r include = TRUE}
cat(comment(groups))
```

## getSummaryPatterns
Because analyzing the results of the `groupClusters()` function might be a lot of work, cMut provides the `getSummaryPatterns()` function to summaries the pattern intersection. The result of this function will show the frequency of the patterns (the number of mutations in the matching clusters with this pattern) and the percentage (frequency pattern is compared with the number of clustered mutations). The `unidentified` row contains the information about the clusters that didn't have a linked pattern.
```{r include = TRUE}
getSummaryPatterns(groups)
```


## shuffleMutations
Since the `getSummaryPatterns()` function is most likely the final function to use, it might be handy to know how likely those results with linked patterns might happen though chance alone. The `shuffleMutations()` is able to shuffle the reference, alternative and surrounding nucleotides at random. Then it execute the `identifyAndAnnotateClusters()` and `groupCluster()` function. Finally it will keep track on how many times the patterns are found which might give a hint of reliability of the results of the real data. With the `nBootstrap` argument it is possible to choose the number of repeats this function has to make. Make sure to use only the mutations that are clustered in the real data for a proper indication.
```{r include = TRUE}
clusteredMut <- results[results$is.clustered == TRUE,]
shuffle <- shuffleMutations(clusteredMut,
                            nBootstrap = 5,
                            no.cores = 1)
```
```{r echo = FALSE}
while(shuffle[8,"percentage"][[1]] == 100){
  shuffle <- shuffleMutations(clusteredMut,nBootstrap = 5,
                            no.cores = 1)  
}
shuffle
```

If cluster patterns are also needed to be evaluated:
```{r include = TRUE}
clusteredMut <- results[results$is.clustered == TRUE,]
shuffle <- shuffleMutations(clusteredMut,
                            nBootstrap = 5,
                            searchClusterPatterns = T,
                            no.cores = 1)
```
```{r echo = FALSE}
while(shuffle[11,"percentage"][[1]] == 100){
  shuffle <- shuffleMutations(clusteredMut,
                              nBootstrap = 5,
                            searchClusterPatterns = T,
                            no.cores = 1)  
}
shuffle
```

### Bugs, questions, suggestions?
Feel free to the contact the creator! (^__^)
alex.janse@radboudumc.nl
